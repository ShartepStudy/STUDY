Мьютекс – это объект, который гарантирует потокам монопольный доступ к одному и тому же ресурсу. 

Мьютекс содержит поля:
•	идентификатор потока - владельца (какой именно поток захватил мьютекс)
•	счетчик рекурсии (сколько раз это произошло)

Мьютексы очень похожи на критические секции. Однако если критические секции являются объектами пользовательского режима,
то мьютексы — это объекты ядра. Поэтому они позволяют синхронизировать доступ к ресурсу нескольких потоков из разных процессов.

Как правило, с их помощью защищают блок памяти, к которому обращается множество потоков.
Если бы потоки одновременно использовали какой-то блок памяти, то данные в нем были бы повреждены.
Мьютексы гарантируют, что любой поток получает монопольный доступ к блоку памяти, и тем самым обеспечивают целостность данных. 

.........................................

Для использования объекта-мьютекса один из потоков должен сначала  создать его вызовом функции API CreateMutex.


HANDLE  CreateMutex(
	LPSECURITY_ATTRIBUTES lpMutexAttributes, // атрибуты доступа 
	BOOL bInitialOwner, // флаг наличия потока-владельца 
	LPCTSTR pszName // имя объекта 
);

Параметр blnitialOwner определяет начальное состояние мьютекса. Если он имеет значение FALSE, то объект-мьютекс не принадлежит ни одному из потоков и поэтому находится в свободном (сигнальном) состоянии. При этом его идентификатор  потока-владельца и счетчик рекурсии равны нулю.
Если же в этом параметре  передается значение TRUE, то идентификатор потока-владельца в мьютексе приравнивается идентификатору вызывающего потока, а счетчик рекурсии получает  единичное значение. Если идентификатор потока-владельца не равен нулю, мьютекс считается занятым. 
Необходимо отметить, что всякий раз, когда поток захватывает объект-мьютекс, счетчик рекурсии в этом объекте увеличивается на 1. Единственная ситуация, в которой значение счетчика рекурсии может быть больше 1, - поток захватывает один и тот же мьютекс несколько раз.

.........................................

Любой поток может получить дескриптор существующего объекта-мьютекса, вызвав функцию API OpenMutex.

HANDLE OpenMutex(
    DWORD dwDesiredAccess,// права доступа (MUTEX_ALL_ACCESS – полный доступ)
    BOOL blnheritHandle, // параметр определяет, будет ли наследоваться дескриптор мьютекса (если TRUE – дескриптор наследуемый)
    LPCTSTR pszName // имя мьютекса
);

.........................................

Для получения доступа к разделяемому ресурсу поток обычно вызывает функцию WaitForSingleObject и передает ей дескриптор мьютекса, охраняющего этот ресурс. 

DWORD WaitForSingleObject(
	HANDLE hHandle, // дескриптор объекта ядра «мьютекс»
	DWORD dwMilliseconds // время ожидания
);

Когда некоторый поток вызывает функцию WaitForSingleObject, параметр hHandle идентифицирует объект ядра «мьютекс», который может находится либо в свободном, либо в занятом состоянии. Параметр dwMilliseconds задает тайм-аут — временной интервал, спустя который функция возвращает управление, даже если объект остается в занятом состоянии. Если параметр dwMilliseconds имеет нулевое значение, то функция только проверяет состояние объекта и возвращает управление немедленно. Константа INFINITE в качестве  значения dwMilliseconds задает бесконечное значение тайм-аута.

Возвращаемым значением функции WaitForSingleObject чаще всего является одна из следующих констант:

Константа	Интерпретация

WAIT_OBJECT_0	Контролируемый объект ядра перешел в свободное (сигнальное) состояние, т.е. произошел захват мьютекса
WAIT_TIMEOUT	Истек  интервал  тайм-аута, а  контролируемый объект ядра остался в занятом (несигнальном) состоянии
WAIT_FAILED	Функция завершилась с ошибкой.
WAIT_ABANDONED	Объект мьютекса не был освобожден тем потоком, который им владел, по причине того, что поток был некорректно завершен. В этом случае мьютекс переводится в сигнальное состояние и им овладевает тот поток, который его ожидал.

Функция WaitForSingleObject проверяет у мьютекса идентификатор потока-владельца. Если идентификатор равен нулю, то ресурс свободен и вызывающий поток может продолжить выполнение. В этом случае перед возвратом из функции идентификатор  потока-владельца в мьютексе становится равным идентификатору вызывающего потока, а счетчику рекурсии присваивается единичное значение. 

Если функция WaitForSingleObject определяет, что идентификатор потока-владельца не  равен нулю, то вызывающий поток переходит в состояние ожидания до тех пор, пока мьютекс не перейдет в сигнальное состояние, т.е. пока захваченный мьютекс не будет освобожден.

.........................................

Когда поток, занимающий ресурс, заканчивает с ним работать, он должен освободить мьютекс вызовом функции API ReleaseMutex.

BOOL ReleaseMutex(
	HANDLE hMutex // дескриптор мьютекса
);

Функция ReleaseMutex уменьшает значение счетчика рекурсии в мьютексе на единицу. Если счетчик рекурсии становится равным нулю, то обнуляется также идентификатор потока-владельца.
Система допускает рекурсивный многократный захват мьютекса одним потоком. В этом случае счетчик рекурсии в мьютексе каждый раз увеличивается на единицу. Важно отметить, что в этой ситуации для освобождения мьютекса количество вызовов потоком функции ReleaseMutex должно совпадать с количеством предыдущих захватов мьютекса.


помимо рассмотренной выше функции WaitForSingleObject иногда используется функция WaitForMultipleObjects. Она работает так же, как и функция WaitForSingleObject, но при этом позволяет ждать освобождения сразу нескольких объектов или какого-то одного объекта из заданного списка.

DWORD WaitForMultipleObjects(
  DWORD nCount, // количество объектов ядра - это значение должно быть в пределах от 1 до MAXIMUM_WAIT_OBJECTS (64)
  CONST HANDLE* lpHandles, // указатель на массив описателей объектов ядра
  BOOL fWaitAll, // Значение TRUE задает режим ожидания  освобождения всех указанных объектов ядра, а FALSE — только одного из них.
  DWORD dwMilliseconds // время ожидания
);

Возвращаемое функцией значение сообщает, почему возобновилось выполнение вызвавшего ее потока. Значения WAIT_TIMEOUT и
WAIT_FAILED  интерпретируются по аналогии с функцией WaitForSingleObject. Если параметр fWaitAll равен TRUE и все
объекты перешли в свободное состояние, то функция возвращает значение WAIT_OBJECT_0. Если же fWaitAll имеет значение FALSE, то функция возвращает  управление, как только освобождается любой из объектов. При этом ее код возврата лежит в интервале от WAIT_OBJECT_0 до WAIT_OBJECT_0 + nCount - 1. Иными словами, если из кода возврата вычесть константу WAIT_OBJECT_0, то получится индекс освободившегося объекта в массиве lpHandles.
